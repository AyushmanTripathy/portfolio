[{"id":"listening_to_songs","tags":["shellscripting","linux","automation"],"heading":"Listening to songs, like chads","html":"<p>I use Arch Btw.</p>\n<p>For context, I have this ancient laptop, and I love listening to random songs on YouTube while coding. However, my computer tends to get pretty toasty, hitting around 70Â°C, especially if I try to have YouTube open while doing something else. So, Iâ€™ve decided to do some shell scripting.</p>\n<h2>The Script</h2>\n<p>First of all, I got all YouTube video IDs from the playlist I listen to. (it has 1161 songs)</p>\n<pre><code class=\"language-sh\">yt-dlp --flat-playlist --print id &quot;&lt;playlist url here&gt;&quot; &gt; ids.txt\n</code></pre>\n<p>the playlist URL I used, <a href=\"https://youtu.be/kJQP7kiw5Fk?list=PL15B1E77BB5708555\">https://youtu.be/kJQP7kiw5Fk?list=PL15B1E77BB5708555</a>. you can use your favorite.</p>\n<p>now I wrote a very simple shell script to download the songs (using yt-dlp) and play them (using mpv). you can choose a different media player. make sure to check out yt-dlp if you havenâ€™t already.</p>\n<pre><code class=\"language-sh\">#!/bin/sh\n\nif [ ! -f &quot;./current_id.txt&quot; ]; then\n  echo &quot;1&quot; &gt; ./current_id.txt\n  mkdir playing played\nfi\n\nwhile true\ndo\n  current_id=$(cat ./current_id.txt)\n  expr &quot;$current_id&quot; &quot;+&quot; 1 &gt; ./current_id.txt\n  song_id=$(head &quot;-$current_id&quot; &lt; ids.txt | tail -1)\n  echo &quot;$song_id&quot;\n  yt-dlp -f wa &quot;$song_id&quot; -o &quot;./playing/%(title)s.%(ext)s&quot;\n  mpv playing/*\n  mv playing/* played/\ndone\n</code></pre>\n<p>after saving the script in a file, run it</p>\n<pre><code class=\"language-sh\">sh script.sh\n</code></pre>\n<h2>Explanation</h2>\n<p>We are keeping track of the last video played using the current_id.txt file, we increment it every time by one using expr command. head and tail commands are to get the nth line from the ids.txt file</p>\n<p>the -f wa option for yt-dlp selects the worst quality audio-only format (because I have shitty internet).</p>\n<p>yt-dlp downloads the song in the playing directory, after mpv plays the song, it is moved to the played directory.</p>\n<h2>Conclusion</h2>\n<p>Shell scripting is the best skill I have learned, and would highly encourage you to give it a try, it&#39;s seriously awesome.</p>\n<p>also here is my <a href=\"https://github.com/AyushmanTripathy\">github</a>.</p>\n<p>I later upgraded the script to do things like handle multiple playlists, caching of downloaded songs, and much more, you can find it <a href=\"https://github.com/ayushmantripathy/bin/blob/master/ytp\">here</a>.</p>\n<p>Liked the script, check out <a href=\"https://github.com/AyushmanTripathy/bin\">my local bin</a>.</p>\n"},{"id":"making_jukebox_videos","tags":["shellscripting","linux","automation"],"heading":"Making Jukebox videos, Automated.","html":"<p>Meet two good friends of mine, FFmpeg &amp; Shellscripting.</p>\n<p>I was procrastinating studying a day before my end sems, as one usually does and I came across a few jukebox videos, and noticed the views count ðŸ¤¯. Let&#39;s make some then, without manual labor of course.</p>\n<p>What do we need? a few songs and a background image.</p>\n<h2>Creating the song compilation</h2>\n<p>Let&#39;s assume you have all your songs in a directory called songs, we want to have all the song names in a .txt file, so</p>\n<pre><code class=\"language-sh\">for i in songs/*\ndo\n  echo $i &gt;&gt; songs.txt\ndone\n</code></pre>\n<p>why not a <code>ls &gt; songs.txt</code>ðŸ¤”, because that puts &quot;songs.txt&quot; itself in songs.txt.</p>\n<p>Now we can edit this song.txt file to define the order of the songs, FFmpeg requires the file names to be listed in specific ways</p>\n<pre><code class=\"language-sh\">for i in $(cat songs.txt)\ndo\n  echo &quot;file $i&quot; &gt;&gt; sequence.txt\ndone\nffmpeg -f concat -i sequence.txt audio.mp4\nrm sequence.txt\n</code></pre>\n<p>Now we have the compilation in audio.mp4. You may be wondering why I wrote to a separate .txt file, because it will be helpful when generating the timestamps.</p>\n<h2>Creating the background video</h2>\n<p>we need to convert the image to a .mp4 video of the same duration. First let us get the duration in seconds,</p>\n<pre><code class=\"language-sh\">duration=$(ffprobe -i audio.mp4 -show_entries format=duration -v quiet -of csv=&quot;p=0&quot;)\n</code></pre>\n<p>These durations can be long, like hours long. encoding that video that long may cause my CPU to commit suicide. So let&#39;s make some jugaad.</p>\n<p>What we can do instead is make a 10s video of the still image and concat it with itself many times to get a longer video, how many times?</p>\n<pre><code class=\"language-sh\">count=$(echo &quot;console.log(Math.ceil(Math.log10($duration)) - 1)&quot; | node)\n</code></pre>\n<p>make the first 10s video. I have taken 1920x1080 resolution.</p>\n<pre><code class=\"language-sh\">ffmpeg -loop 1 -i background.jpg -t 10 -pix_fmt yuv420p -vf scale=1080:1920 clip.mp4\n</code></pre>\n<p>each time we increase the videoâ€™s length by ten times,</p>\n<pre><code class=\"language-sh\"># required format for FFmpeg.\necho &quot;file clip.mp4&quot; &gt; clips.txt\nfor i in $(seq 9)\ndo\n  echo &quot;file clip.mp4&quot; &gt;&gt; clips.txt\ndone\n\n# video concat\nfor i in $(seq $count)\ndo\n  ffmpeg -f concat -i clips.txt -c copy tmp.mp4\n  mv tmp.mp4 clip.mp4\ndone\n</code></pre>\n<p>Finally, let&#39;s put the video and audio together.</p>\n<pre><code class=\"language-sh\">ffmpeg -i clip.mp4 -i audio.mp4 -map 0:v -map 1:a -c copy -shortest final.mp4\n</code></pre>\n<h2>Writing Timestamps</h2>\n<p>We also need to divide the video into chapters for YouTube. we need a format like this,</p>\n<pre><code class=\"language-sh\">00:00:00 baller\n00:02:33 you and me\n00:05:23 her\n00:07:57 elevated\n00:11:18 we rollin\n00:14:37 still rollin\n00:17:28 king shit\n</code></pre>\n<p>It can be achieved by using the songs.txt file we created earlier and some sed editing to remove file extensions and â€˜_â€™s</p>\n<pre><code class=\"language-sh\">\ntime=&quot;0&quot;\nfor i in $(cat songs.txt) \ndo\n  echo &quot;$(date -d@$time -u +%H:%M:%S) $i&quot; | sed -e &quot;s/_/ /g&quot; -e &quot;s/\\..*$//&quot; &gt;&gt; timestamps.txt\n  duration=$(ffprobe -i $i -show_entries format=duration -v quiet -of csv=&quot;p=0&quot; | sed -e &#39;s/\\..*$//&#39;)\n  time=$(expr $duration \\+ $time)\ndone\n</code></pre>\n<p>Here you go, all done.</p>\n<p>Upload the video to YouTube, copy and paste the timestamps into the description, and hopefully you will be famous in no time.</p>\n<p>The entire script can be found in <a href=\"https://github.com/AyushmanTripathy/bin/blob/master/make-jukebox\">my local bin</a>. An example youtube video I made is <a href=\"https://youtu.be/LJz52o5rlW0\">here</a>.</p>\n<p>Have a nice day!</p>\n"},{"id":"my_cp_setup","tags":["shellscripting","linux","automation"],"heading":"My CP Setup","html":"<p>Of course i wrote some shell script to automate stuff, lets check them out, shall we?</p>\n<h2>Running Tests</h2>\n<p>you can find the script in my <a href=\"https://github.com/AyushmanTripathy/bin/blob/master/runtests\">bin</a>. download the script and place it in your local bin.</p>\n<pre><code class=\"language-sh\"># to add a test case\nruntests -a\n# paste your input and enter a empty line\n# paste your expected output and enter a empty line\n</code></pre>\n<p>You can add multiple test cases this way. then to run you code against it,</p>\n<pre><code class=\"language-sh\">runtests &lt;your file&gt;\n</code></pre>\n<p>It currently supports py, cpp and js extensions. In case any of the test case fails, it will print your output and expected output side by side, like this</p>\n<pre><code class=\"language-sh\">CASE #1 [ failed ]\n3                      2\n</code></pre>\n<p>It handles infinite loops by giving a TLE and incase all the test cases pass, congrats ðŸ¥³. and by the way</p>\n<pre><code class=\"language-sh\"># to remove all the test cases\nruntests -c\n# to view test cases\nruntests -v\n</code></pre>\n<h2>How it works?</h2>\n<p>let me explain how it works. It creates a directory structure like the following to store test cases,</p>\n<pre><code class=\"language-sh\">.\nâ”œâ”€â”€ 1\nâ”‚   â”œâ”€â”€ input.txt\nâ”‚   â””â”€â”€ output.txt\nâ””â”€â”€ counter\n</code></pre>\n<p>This counter file stores the number of test cases. each test case (denoted by a number) is stored as a directory with 2 files, input (in input.txt) and expected output (in output.txt). code for reading these files is as follows,</p>\n<pre><code class=\"language-sh\"># $1 is name of the file to write to \nread_input() {\n  rm -f $1\n  while read line\n  do\n    # break if the line is empty\n    [ -z &quot;$line&quot; ] &amp;&amp; break\n    # sed is used to trim spaces\n    echo &quot;$line&quot; | sed -e &#39;s/^\\s*//g&#39; -e &#39;s/\\s*$//g&#39; &gt;&gt; &quot;$1&quot;\n  done\n}\n</code></pre>\n<p>To compare files it uses the diff command. to print text side by side pr command is used. like for example for.py extensions</p>\n<pre><code class=\"language-sh\"># $1 is code file name\n# $2 is base directory\n# $3 is test case number\nrun_py_test_case() {\n  green &quot;CASE #$3 &quot;\n\n  cat &quot;$2/input.txt&quot; | timeout 3s python3 &quot;$1&quot; &gt; &quot;$base_loc/out&quot; || error &quot;runtime error&quot;\n  if diff &quot;$base_loc/out&quot; &quot;$2/output.txt&quot; -white &gt; /dev/null; then\n    green &quot;[ passed ]\\n&quot;\n  else\n    red &quot;[ failed ]\\n&quot;\n    pr -m -t &quot;$base_loc/out&quot; &quot;$2/output.txt&quot;\n    printf &quot;\\n&quot;\n  fi\n\n  rm &quot;$base_loc/out&quot;\n}\n</code></pre>\n<p>Notice the timeout 3s it is used to terminate execution if the script takes more than 3s (in case of infinite loops). In that case, we get a TLE.</p>\n<p>script has a similar function for js and cpp files. based on the extension of the code file, any one of these is called.</p>\n"}]